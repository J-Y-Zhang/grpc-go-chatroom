
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>client: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/zjy-dev/grpc-go-chatroom/client/main.go (0.0%)</option>
				
				<option value="file1">github.com/zjy-dev/grpc-go-chatroom/internal/jwt/jwt.go (85.7%)</option>
				
				<option value="file2">github.com/zjy-dev/grpc-go-chatroom/internal/middlewares/middlewares.go (100.0%)</option>
				
				<option value="file3">github.com/zjy-dev/grpc-go-chatroom/internal/proto/chat.pb.go (12.4%)</option>
				
				<option value="file4">github.com/zjy-dev/grpc-go-chatroom/internal/proto/chat_grpc.pb.go (0.0%)</option>
				
				<option value="file5">github.com/zjy-dev/grpc-go-chatroom/internal/tokensource/tokensource.go (100.0%)</option>
				
				<option value="file6">github.com/zjy-dev/grpc-go-chatroom/server/auth.go (83.3%)</option>
				
				<option value="file7">github.com/zjy-dev/grpc-go-chatroom/server/main.go (79.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "context"
        "fmt"
        "io"
        "log"
        "os"
        "time"

        "github.com/urfave/cli/v2"
        "github.com/zjy-dev/grpc-go-chatroom/internal/tokensource"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"

        pb "github.com/zjy-dev/grpc-go-chatroom/internal/proto"
)

var (
        port     int64
        username string
        token    string
)

// mustLogin function logs in the user to the chatroom
func mustLogin(client pb.ChatServiceClient) <span class="cov0" title="0">{

        // Send a login request to the server
        loginResp, err := client.LogIn(context.Background(), &amp;pb.LoginReq{
                Username: username,
        })
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("client.LogIn failed: %v", err)
        }</span>

        // Check if the server returned an empty response
        <span class="cov0" title="0">if loginResp == nil </span><span class="cov0" title="0">{
                log.Fatalf("server returned an empty client.LogIn response: %v", err)
        }</span>
        // Check if the server returned an empty token
        <span class="cov0" title="0">if len(loginResp.GetToken()) == 0 </span><span class="cov0" title="0">{
                log.Fatalf("server returned an empty token: %v", err)
        }</span>

        // Set the token
        <span class="cov0" title="0">token = loginResp.GetToken()</span>
}

// runChat function runs the chatroom
func runChat(client pb.ChatServiceClient) <span class="cov0" title="0">{
        // Create a stream to the server
        stream, err := client.Chat(context.Background(), grpc.PerRPCCredentials(tokensource.New(token)))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("client.Chat failed: %v", err)
        }</span>

        // Create a channel to wait for the server to send a message
        <span class="cov0" title="0">waitc := make(chan struct{})

        // Start a goroutine to receive messages from the server
        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        in, err := stream.Recv()
                        if err == io.EOF </span><span class="cov0" title="0">{
                                close(waitc)
                                return
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("client.RouteChat failed: %v", err)
                        }</span>

                        // Print the message from the server
                        <span class="cov0" title="0">fmt.Printf("[%s] %s\n", time.Unix(in.GetTimestamp(), 0).Format("2006-01-02 15:04:05"), in.GetText())</span>
                }
        }()

        // Create a scanner to read from standard input
        <span class="cov0" title="0">scanner := bufio.NewScanner(os.Stdin)
        for scanner.Scan() </span><span class="cov0" title="0">{
                // Create a message to send to the server
                msg := &amp;pb.Message{
                        Text:      scanner.Text(),
                        Timestamp: time.Now().Unix(),
                }

                // Send the message to the server
                err := stream.Send(msg)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatalf("%v.Send(%v) = %v", client, msg, err)
                }</span>
                <span class="cov0" title="0">time.Sleep(time.Second * 1)</span>
        }

        // Check if there was an error reading from standard input
        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                stream.CloseSend()
                log.Fatalf("reading standard input: %v", err)
        }</span>
        <span class="cov0" title="0">stream.CloseSend()

        // Wait for the server to send a message
        &lt;-waitc</span>

}

// mustNewClient function creates a new client connection to the server
func mustNewClient() (*grpc.ClientConn, pb.ChatServiceClient) <span class="cov0" title="0">{

        // Create a new client connection to the server
        conn, err := grpc.NewClient(fmt.Sprintf("localhost:%d", port),
                grpc.WithTransportCredentials(insecure.NewCredentials()))
        if err != nil </span><span class="cov0" title="0">{

                log.Fatalf("fail to dial: %v", err)
        }</span>

        // Return the connection and client
        <span class="cov0" title="0">return conn, pb.NewChatServiceClient(conn)</span>
}

// main function is the entry point of the program
func main() <span class="cov0" title="0">{

        // Create a new cli app
        chatroomClient := &amp;cli.App{
                Name:  "grpc-go-chatroom client",
                Usage: "grpc-go chatroom client, written for learning purposes",

                // Define the action to be taken when the app is run
                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{

                        // Create a new client connection to the server
                        conn, client := mustNewClient()
                        defer conn.Close()

                        // Log in the user to the chatroom
                        mustLogin(client)

                        // Run the chatroom
                        runChat(client)
                        return nil
                }</span>,
                // Define the flags for the app
                Flags: []cli.Flag{

                        &amp;cli.Int64Flag{
                                Name:        "port",
                                Aliases:     []string{"p"},
                                Value:       50051,
                                Usage:       "the server port",
                                Destination: &amp;port,
                        },

                        &amp;cli.StringFlag{
                                Name:        "name",
                                Aliases:     []string{"n"},
                                Required:    true,
                                Usage:       "username for the chatroom",
                                Destination: &amp;username,
                        },
                },
        }

        // Run the cli app
        <span class="cov0" title="0">if err := chatroomClient.Run(os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package jwt

import (
        "log"
        "os"

        "github.com/golang-jwt/jwt/v5"
        "github.com/joho/godotenv"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// jwtKey is a global variable that stores the JWT key
var jwtKey string

// init function is used to load the .env file and set the jwtKey variable
func mustLoadJwtKey() <span class="cov8" title="1">{

        if os.Getenv("JWT_KEY") != "" </span><span class="cov8" title="1">{
                jwtKey = os.Getenv("JWT_KEY")
                return
        }</span>
        // Load the .env file
        <span class="cov8" title="1">err := godotenv.Load()
        if err != nil </span><span class="cov8" title="1">{
                // Log an error if the .env file cannot be loaded
                pwd, _ := os.Getwd()
                log.Panicf("error loading .env file: %v, current working directory: %v", err, pwd)
        }</span>

        <span class="cov8" title="1">if jwtKey = os.Getenv("JWT_KEY"); jwtKey == "" </span><span class="cov0" title="0">{
                log.Panicf("no JWT_KEY in .env")
        }</span>

}

// GenerateJwt function generates a JWT token with the given username
func GenerateJwt(username string) (string, error) <span class="cov8" title="1">{
        if username == "" </span><span class="cov8" title="1">{
                return "", status.Errorf(codes.InvalidArgument, "username is empty")
        }</span>
        // Check if the jwtKey variable is already set
        <span class="cov8" title="1">if jwtKey == "" </span><span class="cov0" title="0">{
                mustLoadJwtKey()
        }</span>

        // Create a new JWT token with the given username
        <span class="cov8" title="1">token := jwt.NewWithClaims(jwt.SigningMethodHS256,
                jwt.RegisteredClaims{
                        Subject: username,
                },
        )

        // Sign the token with the jwtKey
        tokenString, err := token.SignedString([]byte(jwtKey))
        if err != nil </span><span class="cov0" title="0">{
                return "", status.Errorf(codes.Internal, "failed to sign token: %v", err)
        }</span>
        <span class="cov8" title="1">return tokenString, nil</span>
}

// ParseJwt function parses a JWT token and returns the claims
func ParseJwt(tokenString string) (*jwt.RegisteredClaims, error) <span class="cov8" title="1">{
        if tokenString == "" </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "token is empty")
        }</span>
        // Parse the token with the jwtKey
        <span class="cov8" title="1">token, err := jwt.ParseWithClaims(tokenString, &amp;jwt.RegisteredClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return []byte(jwtKey), nil
        }</span>)

        // Check if the token is valid
        <span class="cov8" title="1">if err != nil || !token.Valid </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "failed to parse token: %v", err)
        }</span>

        // Parse the claims from the token
        <span class="cov8" title="1">claims, ok := token.Claims.(*jwt.RegisteredClaims)
        if !ok </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "failed to parse claims")
        }</span>

        // Return the claims
        <span class="cov8" title="1">return claims, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package middlewares

import (
        "context"
        "strings"

        "google.golang.org/grpc"
)

type AuthFunc func(ctx context.Context) (context.Context, error)

// UnaryServerAuthInterceptorWithBypassMethods creates a new unary server interceptor.
// The interceptor will call the authFunc only if the request's method name
// doesn't match any of the bypassMethods. The bypassMethods are matched against
// the full method name (e.g. /service.Service/Method).
//
// Returns a grpc.UnaryServerInterceptor.
func UnaryServerAuthInterceptorWithBypassMethods(authFunc AuthFunc, bypassMethods ...string) grpc.UnaryServerInterceptor <span class="cov8" title="1">{
        // This function is the actual interceptor.
        return func(ctx context.Context, req any, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (any, error) </span><span class="cov8" title="1">{
                // Check if the method is in the bypass list.
                for _, method := range bypassMethods </span><span class="cov8" title="1">{
                        if strings.HasSuffix(info.FullMethod, method) </span><span class="cov8" title="1">{
                                // If it is, call the handler directly without calling authFunc.
                                return handler(ctx, req)
                        }</span>
                }

                // If the method isn't in the bypass list, call authFunc and then call the handler.
                <span class="cov8" title="1">ctx, err := authFunc(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return handler(ctx, req)</span>
        }
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// License header (if applicable)
// File overview
// Syntax
// Package
// Imports (sorted)
// File options
// Everything else

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.28.1
//         protoc        v4.25.2
// source: internal/proto/chat.proto

package chat

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Empty struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *Empty) Reset() <span class="cov0" title="0">{
        *x = Empty{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_internal_proto_chat_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Empty) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Empty) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Empty) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_proto_chat_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Empty.ProtoReflect.Descriptor instead.
func (*Empty) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_proto_chat_proto_rawDescGZIP(), []int{0}
}</span>

type LoginReq struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
}

func (x *LoginReq) Reset() <span class="cov0" title="0">{
        *x = LoginReq{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_internal_proto_chat_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginReq) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginReq) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginReq) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_proto_chat_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginReq.ProtoReflect.Descriptor instead.
func (*LoginReq) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_proto_chat_proto_rawDescGZIP(), []int{1}
}</span>

func (x *LoginReq) GetUsername() string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Username
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoginResp struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (x *LoginResp) Reset() <span class="cov0" title="0">{
        *x = LoginResp{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_internal_proto_chat_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoginResp) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoginResp) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoginResp) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_proto_chat_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoginResp.ProtoReflect.Descriptor instead.
func (*LoginResp) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_proto_chat_proto_rawDescGZIP(), []int{2}
}</span>

func (x *LoginResp) GetToken() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Token
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// 定义消息内容
type Message struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Text      string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
        Timestamp int64  `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (x *Message) Reset() <span class="cov0" title="0">{
        *x = Message{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_internal_proto_chat_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Message) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Message) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Message) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_internal_proto_chat_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Message.ProtoReflect.Descriptor instead.
func (*Message) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_internal_proto_chat_proto_rawDescGZIP(), []int{3}
}</span>

func (x *Message) GetText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Text
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Message) GetTimestamp() int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return 0</span>
}

var File_internal_proto_chat_proto protoreflect.FileDescriptor

var file_internal_proto_chat_proto_rawDesc = []byte{
        0x0a, 0x19, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x6c, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2f, 0x63, 0x68, 0x61, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x63, 0x68, 0x61,
        0x74, 0x22, 0x07, 0x0a, 0x05, 0x45, 0x6d, 0x70, 0x74, 0x79, 0x22, 0x26, 0x0a, 0x08, 0x4c, 0x6f,
        0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x12, 0x1a, 0x0a, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x75, 0x73, 0x65, 0x72, 0x6e, 0x61,
        0x6d, 0x65, 0x22, 0x21, 0x0a, 0x09, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x12,
        0x14, 0x0a, 0x05, 0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x74, 0x6f, 0x6b, 0x65, 0x6e, 0x22, 0x3b, 0x0a, 0x07, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
        0x12, 0x12, 0x0a, 0x04, 0x74, 0x65, 0x78, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x74, 0x65, 0x78, 0x74, 0x12, 0x1c, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x03, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
        0x6d, 0x70, 0x32, 0x85, 0x01, 0x0a, 0x0b, 0x43, 0x68, 0x61, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x12, 0x28, 0x0a, 0x05, 0x4c, 0x6f, 0x67, 0x49, 0x6e, 0x12, 0x0e, 0x2e, 0x63, 0x68,
        0x61, 0x74, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x71, 0x1a, 0x0f, 0x2e, 0x63, 0x68,
        0x61, 0x74, 0x2e, 0x4c, 0x6f, 0x67, 0x69, 0x6e, 0x52, 0x65, 0x73, 0x70, 0x12, 0x22, 0x0a, 0x06,
        0x4c, 0x6f, 0x67, 0x4f, 0x75, 0x74, 0x12, 0x0b, 0x2e, 0x63, 0x68, 0x61, 0x74, 0x2e, 0x45, 0x6d,
        0x70, 0x74, 0x79, 0x1a, 0x0b, 0x2e, 0x63, 0x68, 0x61, 0x74, 0x2e, 0x45, 0x6d, 0x70, 0x74, 0x79,
        0x12, 0x28, 0x0a, 0x04, 0x43, 0x68, 0x61, 0x74, 0x12, 0x0d, 0x2e, 0x63, 0x68, 0x61, 0x74, 0x2e,
        0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x1a, 0x0d, 0x2e, 0x63, 0x68, 0x61, 0x74, 0x2e, 0x4d,
        0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x28, 0x01, 0x30, 0x01, 0x42, 0x08, 0x5a, 0x06, 0x2e, 0x2f,
        0x63, 0x68, 0x61, 0x74, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_internal_proto_chat_proto_rawDescOnce sync.Once
        file_internal_proto_chat_proto_rawDescData = file_internal_proto_chat_proto_rawDesc
)

func file_internal_proto_chat_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_internal_proto_chat_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_internal_proto_chat_proto_rawDescData = protoimpl.X.CompressGZIP(file_internal_proto_chat_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_internal_proto_chat_proto_rawDescData</span>
}

var file_internal_proto_chat_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_internal_proto_chat_proto_goTypes = []interface{}{
        (*Empty)(nil),     // 0: chat.Empty
        (*LoginReq)(nil),  // 1: chat.LoginReq
        (*LoginResp)(nil), // 2: chat.LoginResp
        (*Message)(nil),   // 3: chat.Message
}
var file_internal_proto_chat_proto_depIdxs = []int32{
        1, // 0: chat.ChatService.LogIn:input_type -&gt; chat.LoginReq
        0, // 1: chat.ChatService.LogOut:input_type -&gt; chat.Empty
        3, // 2: chat.ChatService.Chat:input_type -&gt; chat.Message
        2, // 3: chat.ChatService.LogIn:output_type -&gt; chat.LoginResp
        0, // 4: chat.ChatService.LogOut:output_type -&gt; chat.Empty
        3, // 5: chat.ChatService.Chat:output_type -&gt; chat.Message
        3, // [3:6] is the sub-list for method output_type
        0, // [0:3] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_internal_proto_chat_proto_init() }</span>
func file_internal_proto_chat_proto_init() <span class="cov8" title="1">{
        if File_internal_proto_chat_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_internal_proto_chat_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Empty); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_internal_proto_chat_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginReq); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_internal_proto_chat_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoginResp); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_internal_proto_chat_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Message); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_internal_proto_chat_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_internal_proto_chat_proto_goTypes,
                DependencyIndexes: file_internal_proto_chat_proto_depIdxs,
                MessageInfos:      file_internal_proto_chat_proto_msgTypes,
        }.Build()
        File_internal_proto_chat_proto = out.File
        file_internal_proto_chat_proto_rawDesc = nil
        file_internal_proto_chat_proto_goTypes = nil
        file_internal_proto_chat_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v4.25.2
// source: internal/proto/chat.proto

package chat

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ChatServiceClient is the client API for ChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChatServiceClient interface {
        LogIn(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error)
        LogOut(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
        Chat(ctx context.Context, opts ...grpc.CallOption) (ChatService_ChatClient, error)
}

type chatServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewChatServiceClient(cc grpc.ClientConnInterface) ChatServiceClient <span class="cov0" title="0">{
        return &amp;chatServiceClient{cc}
}</span>

func (c *chatServiceClient) LogIn(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error) <span class="cov0" title="0">{
        out := new(LoginResp)
        err := c.cc.Invoke(ctx, "/chat.ChatService/LogIn", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *chatServiceClient) LogOut(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) <span class="cov0" title="0">{
        out := new(Empty)
        err := c.cc.Invoke(ctx, "/chat.ChatService/LogOut", in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *chatServiceClient) Chat(ctx context.Context, opts ...grpc.CallOption) (ChatService_ChatClient, error) <span class="cov0" title="0">{
        stream, err := c.cc.NewStream(ctx, &amp;ChatService_ServiceDesc.Streams[0], "/chat.ChatService/Chat", opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">x := &amp;chatServiceChatClient{stream}
        return x, nil</span>
}

type ChatService_ChatClient interface {
        Send(*Message) error
        Recv() (*Message, error)
        grpc.ClientStream
}

type chatServiceChatClient struct {
        grpc.ClientStream
}

func (x *chatServiceChatClient) Send(m *Message) error <span class="cov0" title="0">{
        return x.ClientStream.SendMsg(m)
}</span>

func (x *chatServiceChatClient) Recv() (*Message, error) <span class="cov0" title="0">{
        m := new(Message)
        if err := x.ClientStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// ChatServiceServer is the server API for ChatService service.
// All implementations must embed UnimplementedChatServiceServer
// for forward compatibility
type ChatServiceServer interface {
        LogIn(context.Context, *LoginReq) (*LoginResp, error)
        LogOut(context.Context, *Empty) (*Empty, error)
        Chat(ChatService_ChatServer) error
        mustEmbedUnimplementedChatServiceServer()
}

// UnimplementedChatServiceServer must be embedded to have forward compatible implementations.
type UnimplementedChatServiceServer struct {
}

func (UnimplementedChatServiceServer) LogIn(context.Context, *LoginReq) (*LoginResp, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method LogIn not implemented")
}</span>
func (UnimplementedChatServiceServer) LogOut(context.Context, *Empty) (*Empty, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method LogOut not implemented")
}</span>
func (UnimplementedChatServiceServer) Chat(ChatService_ChatServer) error <span class="cov0" title="0">{
        return status.Errorf(codes.Unimplemented, "method Chat not implemented")
}</span>
func (UnimplementedChatServiceServer) mustEmbedUnimplementedChatServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatServiceServer will
// result in compilation errors.
type UnsafeChatServiceServer interface {
        mustEmbedUnimplementedChatServiceServer()
}

func RegisterChatServiceServer(s grpc.ServiceRegistrar, srv ChatServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;ChatService_ServiceDesc, srv)
}</span>

func _ChatService_LogIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(LoginReq)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ChatServiceServer).LogIn(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/chat.ChatService/LogIn",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ChatServiceServer).LogIn(ctx, req.(*LoginReq))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ChatService_LogOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(Empty)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(ChatServiceServer).LogOut(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: "/chat.ChatService/LogOut",
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ChatServiceServer).LogOut(ctx, req.(*Empty))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ChatService_Chat_Handler(srv interface{}, stream grpc.ServerStream) error <span class="cov0" title="0">{
        return srv.(ChatServiceServer).Chat(&amp;chatServiceChatServer{stream})
}</span>

type ChatService_ChatServer interface {
        Send(*Message) error
        Recv() (*Message, error)
        grpc.ServerStream
}

type chatServiceChatServer struct {
        grpc.ServerStream
}

func (x *chatServiceChatServer) Send(m *Message) error <span class="cov0" title="0">{
        return x.ServerStream.SendMsg(m)
}</span>

func (x *chatServiceChatServer) Recv() (*Message, error) <span class="cov0" title="0">{
        m := new(Message)
        if err := x.ServerStream.RecvMsg(m); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return m, nil</span>
}

// ChatService_ServiceDesc is the grpc.ServiceDesc for ChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "chat.ChatService",
        HandlerType: (*ChatServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "LogIn",
                        Handler:    _ChatService_LogIn_Handler,
                },
                {
                        MethodName: "LogOut",
                        Handler:    _ChatService_LogOut_Handler,
                },
        },
        Streams: []grpc.StreamDesc{
                {
                        StreamName:    "Chat",
                        Handler:       _ChatService_Chat_Handler,
                        ServerStreams: true,
                        ClientStreams: true,
                },
        },
        Metadata: "internal/proto/chat.proto",
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package tokensource

import (
        "context"
)

// Auth is an implementation of grpc.PerRPCCredentials interface
type Auth struct {
        token string
}

// New creates a new Auth object with the given token
func New(token string) Auth <span class="cov8" title="1">{
        return Auth{
                token: token,
        }
}</span>

// GetRequestMetadata returns the metadata for the request
func (a Auth) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) <span class="cov8" title="1">{

        // Create a map to store the metadata
        metadataMap := make(map[string]string)

        // Add the authorization header to the metadata map
        metadataMap["authorization"] = "bearer " + a.token

        // Return the metadata map
        return metadataMap, nil
}</span>

// RequireTransportSecurity returns whether or not the transport security is required
func (a Auth) RequireTransportSecurity() bool <span class="cov8" title="1">{

        // Return false as the transport security is not required
        return false
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "context"

        authmiddleware "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/auth"
        "github.com/zjy-dev/grpc-go-chatroom/internal/jwt"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"
)

// authFunc is a function that authenticates incoming requests.
func authFunc(ctx context.Context) (context.Context, error) <span class="cov8" title="1">{
        // Get the token from the metadata.
        token, err := authmiddleware.AuthFromMD(ctx, "bearer")

        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "invalid auth token prefix: %v", err)
        }</span>

        // Parse the token.
        <span class="cov8" title="1">claims, err := jwt.ParseJwt(token)
        if err != nil </span><span class="cov8" title="1">{
                return nil, status.Errorf(codes.InvalidArgument, "parse token failed: %v", err)
        }</span>
        // Get the subject from the claims.
        <span class="cov8" title="1">subject, err := claims.GetSubject()

        // This err is forever nil due to the design
        if err != nil </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.Internal, "get subject failed: %v", err)
        }</span>

        <span class="cov8" title="1">if subject == "" </span><span class="cov0" title="0">{
                return nil, status.Errorf(codes.InvalidArgument, "username is empty")
        }</span>

        // TODO:
        <span class="cov8" title="1">return context.WithValue(ctx, "username", subject), nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        "log"
        "net"
        "os"
        "sync"

        "github.com/urfave/cli/v2"
        "github.com/zjy-dev/grpc-go-chatroom/internal/jwt"
        "github.com/zjy-dev/grpc-go-chatroom/internal/middlewares"
        "google.golang.org/grpc"
        "google.golang.org/grpc/codes"
        "google.golang.org/grpc/status"

        authmiddleware "github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/auth"
        pb "github.com/zjy-dev/grpc-go-chatroom/internal/proto"
)

var port int64

// chatServer is a struct that implements the ChatServiceServer interface.
type chatServer struct {
        pb.UnimplementedChatServiceServer // UnimplementedChatServiceServer is the server API for ChatService service.

        clientsMap map[string]pb.ChatService_ChatServer // username -&gt; client stream
        mu         sync.Mutex                           // mu guards the clientsMap
}

// LogIn is a method that implements the LogIn method of the ChatServiceServer interface.
func (cs *chatServer) LogIn(ctx context.Context, req *pb.LoginReq) (*pb.LoginResp, error) <span class="cov8" title="1">{

        // Check if the username is empty.
        if req.GetUsername() == "" </span><span class="cov8" title="1">{

                return nil, status.Errorf(codes.InvalidArgument, "username is empty")
        }</span>

        // Lock the mutex to prevent concurrent access to the clientsMap.
        <span class="cov8" title="1">cs.mu.Lock()
        defer cs.mu.Unlock()

        // Check if the user has already logged in.
        if _, ok := cs.clientsMap[req.GetUsername()]; ok </span><span class="cov8" title="1">{

                return nil, status.Errorf(codes.AlreadyExists, "user: %s has already logged in", req.GetUsername())
        }</span>

        // Generate a JWT token for the user.
        <span class="cov8" title="1">token, err := jwt.GenerateJwt(req.GetUsername())
        if err != nil </span><span class="cov0" title="0">{

                return nil, status.Errorf(codes.Internal, "failed to generate jwt: %v", err)
        }</span>

        // Add the user to the clientsMap.
        <span class="cov8" title="1">cs.clientsMap[req.GetUsername()] = nil

        return &amp;pb.LoginResp{Token: token}, nil</span>
}

// LogOut is a method that implements the LogOut method of the ChatServiceServer interface.
func (cs *chatServer) LogOut(ctx context.Context, _ *pb.Empty) (*pb.Empty, error) <span class="cov8" title="1">{

        // Get the username from the context.
        username, ok := ctx.Value("username").(string)
        if !ok || len(username) == 0 </span><span class="cov8" title="1">{
                return &amp;pb.Empty{}, status.Errorf(codes.Unauthenticated, "invalid auth token")
        }</span>
        <span class="cov8" title="1">cs.mu.Lock()
        defer cs.mu.Unlock()
        // Check if the user exists in the clientsMap.
        if _, ok := cs.clientsMap[username]; !ok </span><span class="cov8" title="1">{
                return &amp;pb.Empty{}, status.Errorf(codes.NotFound, "user: %s not found", username)
        }</span>

        // Remove the user from the clientsMap.
        <span class="cov8" title="1">delete(cs.clientsMap, username)
        return &amp;pb.Empty{}, nil</span>
}

// Chat is a method that implements the Chat method of the ChatServiceServer interface.
func (cs *chatServer) Chat(stream pb.ChatService_ChatServer) error <span class="cov8" title="1">{
        // Get the username from the context.
        username, ok := stream.Context().Value("username").(string)
        if !ok || len(username) == 0 </span><span class="cov8" title="1">{
                return status.Errorf(codes.Unauthenticated, "invalid auth token")
        }</span>
        <span class="cov8" title="1">cs.mu.Lock()
        // Check if the user exists in the clientsMap.
        if _, ok := cs.clientsMap[username]; !ok </span><span class="cov8" title="1">{
                cs.mu.Unlock()
                return status.Errorf(codes.NotFound, "user: %s has not logged in, please log in first", username)
        }</span>
        // Add the user to the clientsMap.

        <span class="cov8" title="1">cs.clientsMap[username] = stream

        cs.mu.Unlock()
        for </span><span class="cov8" title="1">{
                // Receive message from client
                msg, err := stream.Recv()
                if err != io.EOF &amp;&amp; msg == nil </span><span class="cov8" title="1">{
                        cs.mu.Lock()
                        delete(cs.clientsMap, username)
                        cs.mu.Unlock()
                        return status.Errorf(codes.InvalidArgument, "empty message")
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        cs.mu.Lock()
                        delete(cs.clientsMap, username)
                        cs.mu.Unlock()
                        if err == io.EOF </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return status.Errorf(codes.Internal, "failed to receive message from client: %v", err)</span>
                }

                // Send message to all clients
                // TODO: CHECK TIMESTAMP
                <span class="cov8" title="1">newMsg := &amp;pb.Message{Text: fmt.Sprintf("%s: %s", username, msg.Text), Timestamp: msg.GetTimestamp()}
                cs.mu.Lock()
                for _, client := range cs.clientsMap </span><span class="cov8" title="1">{
                        go func() </span><span class="cov8" title="1">{
                                if err := client.Send(newMsg); err != nil </span><span class="cov0" title="0">{
                                        log.Printf("failed to send message to client: %v", err)
                                }</span>
                        }()

                        <span class="cov8" title="1">cs.mu.Unlock()</span>

                }
        }
}

// newChatServer creates a new chatServer instance.
func newChatServer() *chatServer <span class="cov8" title="1">{
        s := &amp;chatServer{clientsMap: make(map[string]pb.ChatService_ChatServer)}
        return s
}</span>

func main() <span class="cov0" title="0">{
        // Create a new CLI app.
        chatroomServer := &amp;cli.App{
                Name:  "grpc-go-chatroom server",                                // Set the name of the app.
                Usage: "grpc-go chatroom server, written for learning purposes", // Set the usage message.

                Action: func(cCtx *cli.Context) error </span><span class="cov0" title="0">{
                        // Listen for incoming connections on the specified port.
                        lis, err := net.Listen("tcp", fmt.Sprintf("0.0.0.0:%d", port))
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatalf("failed to listen: %v", err)
                        }</span>

                        // Create a new gRPC server.
                        <span class="cov0" title="0">grpcServer := grpc.NewServer(

                                // Set the stream interceptor to authenticate incoming stream requests.
                                grpc.StreamInterceptor(authmiddleware.StreamServerInterceptor(authFunc)),
                                // Set the unary interceptor to authenticate incoming unary requests.
                                // Exclude the "LogIn" method from authentication.
                                grpc.UnaryInterceptor(middlewares.UnaryServerAuthInterceptorWithBypassMethods(authFunc, "LogIn")),
                        )

                        // Register the chat service server with the gRPC server.
                        pb.RegisterChatServiceServer(grpcServer, newChatServer())

                        // Start the server and serve the chat requests.
                        grpcServer.Serve(lis)
                        return nil</span>
                },

                Flags: []cli.Flag{
                        &amp;cli.Int64Flag{
                                Name:        "port",            // Set the name of the flag.
                                Aliases:     []string{"p"},     // Set the aliases of the flag.
                                Value:       50051,             // Set the default value of the flag.
                                Usage:       "the server port", // Set the usage message of the flag.
                                Destination: &amp;port,             // Set the destination of the flag.
                        },
                },
        }

        // Run the CLI app and handle any errors that occur.
        <span class="cov0" title="0">if err := chatroomServer.Run(os.Args); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
